# Quiz

- 2024.02.08.
- 16 / 20 (80%)

## Q. React의 `useDeferredValue` 훅은 어떤 상황에서 사용되는가?

1. 상태 업데이트를 즉시 반영하려는 경우
2. 상태 업데이트를 지연시키고 싶은 경우
3. 상태 업데이트를 취소하려는 경우
4. 상태 업데이트를 반복하려는 경우

```
정답: 2
(제출한 답: 2)
useDeferredValue 훅은 상태 업데이트를 지연시키는 데 사용된다. 이는 성능 최적화를 위해 사용되며, 특히 렌더링이 느린 컴포넌트에서 유용하다.
```

## Q. React에서 ref는 언제 사용해야 하는가?

1. 컴포넌트의 상태를 변경할 때
2. 컴포넌트의 props를 변경할 때
3. 일반적인 데이터 흐름 외에 자식을 수정해야 할 때
4. 컴포넌트를 렌더링할 때

```
정답: 3
(제출한 답: 3)
React에서 ref는 일반적인 데이터 흐름 외에 자식을 수정해야 할 때 사용된다. 이는 React 컴포넌트의 인스턴스일 수도 있고, DOM 요소일 수도 있다.
```

## Q. React에서 초기 상태가 비싼 계산의 결과인 경우 어떻게 처리해야 하는가?

1. 초기 상태를 계산하는 함수를 useState에 전달한다.
2. 초기 상태를 계산하는 함수를 useReducer에 전달한다.
3. 초기 상태를 계산하는 함수를 useEffect 내부에서 실행한다.
4. 초기 상태를 계산하는 함수를 useMemo 내부에서 실행한다.

```
정답: 1
(제출한 답: 4)
useState의 인자로 함수를 전달하면, 이 함수는 초기 렌더링에서만 실행된다. 따라서 비싼 계산이 필요한 초기 상태는 이 방법으로 처리할 수 있다.
--- 문제에서 물어보는 것은 '상태', state 임
```

## Q. React의 `useImperativeHandle` 훅은 어떤 경우에 사용되는가?

1. 부모 컴포넌트가 자식 컴포넌트의 인스턴스 값을 커스터마이징하려는 경우
2. 레이아웃을 DOM에서 읽고 동기적으로 다시 렌더링하려는 경우
3. React DevTools에서 사용자 정의 훅에 대한 레이블을 표시하려는 경우
4. DOM 노드에 ref를 연결하거나 분리하려는 경우

```
정답: 1
(제출한 답: 1)
useImperativeHandle는 부모 컴포넌트가 자식 컴포넌트의 인스턴스 값을 커스터마이징하려는 경우에 사용된다. 이는 ref를 사용하여 명령형 코드를 작성하는 경우에 주로 사용된다.
--- https://react-ko.dev/reference/react/useImperativeHandle
```

## Q. React의 라이프사이클 메서드 중 어떤 메서드가 컴포넌트가 처음 만들어질 때 실행되는가?

1. componentDidMount
2. componentWillUnmount
3. componentDidUpdate
4. getDerivedStateFromProps

```
정답: 1
(제출한 답: 1)
componentDidMount 메서드는 컴포넌트가 처음 만들어질 때 실행되며, 이 메서드에서 다른 JavaScript 라이브러리 또는 프레임워크의 함수를 호출하거나, 이벤트 등록, setTimeout, setInterval, 네트워크 요청 같은 비동기 작업을 처리하면 된다(클래스형 컴포넌트).
```

## Q. React에서 커스텀 훅을 사용하는 주요 이유는 무엇인가?

1. 컴포넌트 트리에 더 많은 컴포넌트를 추가하기 위해
2. 상태 자체를 재사용하기 위해
3. 상태가 있는 로직을 재사용하기 위해
4. 각 훅 호출이 완전히 격리된 상태를 가지기 때문에

```
정답: 3
(제출한 답: 3)
커스텀 훅은 상태가 있는 로직을 재사용하기 위한 방법이다. 각 훅 호출은 완전히 격리된 상태를 가지므로, 상태 자체를 재사용하는 것이 아니다. 또한, 커스텀 훅을 사용하면 컴포넌트 트리에 더 많은 컴포넌트를 추가하지 않고도 로직을 재사용할 수 있다.
```

## Q. React에서 `contextType` 속성은 어떤 역할을 하는지 설명하라.

25. 가장 가까운 현재 Context 유형의 값을 this.context를 사용하여 소비할 수 있게 한다.
26. 클래스에 할당된 Context 객체를 생성한다.
27. 여러 Context를 동시에 구독할 수 있게 한다.
28. Context의 기본값을 설정한다.

```
정답: 1
(제출한 답: 1)
contextType 속성은 클래스에 할당된 Context 객체를 생성하는 것이 아니라, 가장 가까운 현재 Context 유형의 값을 this.context를 사용하여 소비할 수 있게 한다. 여러 Context를 동시에 구독하거나 Context의 기본값을 설정하는 것은 contextType의 역할이 아니다(클래스형 컴포넌트).
--- https://ko.legacy.reactjs.org/docs/context.html#classcontexttype
```

## Q. React DevTools에서 컴포넌트의 이름을 어떻게 설정하는가?

1. displayName 속성을 설정한다
2. name 속성을 설정한다
3. componentName 속성을 설정한다
4. componentDisplayName 속성을 설정한다

```
정답: 1
(제출한 답: 1)
React DevTools에서 컴포넌트의 이름을 설정하기 위해선, displayName 속성을 설정해야 한다. 이는 DevTools에서 컴포넌트의 이름을 보여주는데 사용된다.
```

## Q. 리액트의 라이프사이클 메서드 중, 리렌더링을 시작할지 여부를 결정하는 메서드는 무엇인가?

1. componentDidMount
2. shouldComponentUpdate
3. getDerivedStateFromProps
4. componentWillUnmount

```
정답: 2
(제출한 답: 2)
shouldComponentUpdate 메서드는 props 또는 state를 변경했을 때, 리렌더링을 시작할지 여부를 결정하는 메서드이다. 이 메서드는 반드시 true 또는 false를 반환해야 한다(클래스형 컴포넌트).
```

## Q. React에서 고차 컴포넌트(HOC)의 주요 목적은 무엇인가?

1. 컴포넌트 로직을 재사용하기 위함
2. 컴포넌트의 렌더링 성능을 향상시키기 위함
3. 컴포넌트의 생명주기를 제어하기 위함
4. 컴포넌트의 상태를 관리하기 위함

```
정답: 1
(제출한 답: 1)
고차 컴포넌트(HOC)는 React에서 컴포넌트 로직을 재사용하는 고급 기술이다. HOC는 React API의 일부가 아니라, 컴포넌트 로직을 재사용하는 패턴이다.
--- 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환한다. `React.memo()` 가 해당 패턴을 적용하고 있다.
--- 주로 클래스형 컴포넌트에서 사용되며, 함수형 컴포넌트에서는 hooks 도입에 따라 HOC 사용 빈도가 줄었으나 여전히 유용하게 활용할 수 있다.
--- https://ko.legacy.reactjs.org/docs/higher-order-components.html
```

## Q. 자바스크립트에서 프로토타입 기반 상속의 특징에 대해 설명하라.

1. 프로토타입 기반 상속은 클래스 기반 상속과 동일하다.
2. 프로토타입 기반 상속은 객체를 복제하여 상속을 구현한다.
3. 프로토타입 기반 상속은 상속을 지원하지 않는다.
4. 프로토타입 기반 상속은 상속을 위해 특별한 문법을 필요로 한다.

```
정답: 2
(제출한 답: 4)
자바스크립트는 프로토타입 기반 언어로, 객체를 원형(prototype)으로 삼고 이를 복제(참조)함으로써 상속과 같은 효과를 얻는다.
--- 프로토타입 기반 언어인 자바스크립트에서 "복제"는 사실상 참조를 의미한다. 즉, 객체 A가 객체 B의 프로토타입일 때 객체 A의 속성은 객체 B에 "복제"되는 것이 아니지만, 프로토타입 체인 메커니즘을 통해 객체 B는 필요에 따라 객체 A의 속성을 참조할 수 있다.
```

## Q. 다음 중 try...catch 구문을 사용하는 주요 이유는 무엇인가?

1. 코드의 실행 속도를 높이기 위해
2. 코드의 재사용성을 높이기 위해
3. 코드의 가독성을 높이기 위해
4. 코드에서 발생할 수 있는 오류를 처리하기 위해

```
정답: 4
(제출한 답: 4)
try...catch 구문은 코드에서 발생할 수 있는 오류를 처리하는 데 사용된다. 이를 통해 프로그램이 예상치 못한 오류로 인해 완전히 중단되는 것을 방지할 수 있다.
```

## Q. JavaScript에서 객체가 생성된 후 프로토타입 속성이 변경되면 어떤 결과가 발생하는가?

1. 객체의 프로토타입 체인이 변경된다.
2. 'obj instanceof Class' 검사의 결과가 변경된다.
3. 객체의 프로토타입 체인이 변경되지 않는다.
4. 객체의 생성자가 변경된다.

```
정답: 2
(제출한 답: 1)
객체가 생성된 후 프로토타입 속성이 변경되면, 'obj instanceof Class' 검사의 결과가 변경될 수 있다. 이는 Class 생성자 자체가 검사에 참여하지 않고, 프로토타입 체인과 Class.prototype만이 중요하기 때문이다.
--- prototype 객체가 변경되는 것이 아닌, prototype 객체의 property 가 변경되는 것을 묻는 문제
--- 프로토타입의 속성을 변경하더라도 프로토타입 체인은 변경되지 않으므로 3번도 옳다. 다만 구체적인 결과를 묻는 질문이므로 2번이 정답이다.
--- https://ko.javascript.info/instanceof
```

## Q. 다음 중 동적 모듈 가져오기와 관련하여 잘못된 설명은 무엇인가?

1. 동적 모듈 가져오기는 항상 기본 내보내기를 사용한다.
2. 동적 모듈 가져오기는 모듈 경로를 동적으로 생성할 수 있다.
3. 동적 모듈 가져오기는 코드의 실행 시간에 모듈을 가져올 수 있게 해준다.
4. 동적 모듈 가져오기는 모듈을 로드하고 모든 내보내기를 포함하는 모듈 객체로 해결되는 약속을 반환한다.

```
정답: 1
(제출한 답: 1)
동적 모듈 가져오기는 기본 내보내기 또는 명명된 내보내기를 사용할 수 있다. 따라서 '동적 모듈 가져오기는 항상 기본 내보내기를 사용합니다.'는 잘못된 설명이다.
--- https://ko.javascript.info/modules-dynamic-imports
```

## Q. 다음 중 자바스크립트에서 클래스 상속을 사용하여 새로운 클래스를 생성하는 과정에 대한 설명으로 올바르지 않은 것은 무엇인가?

1. 자식 클래스는 부모 클래스의 모든 메서드를 상속받는다.
2. 자식 클래스는 부모 클래스의 메서드를 오버라이드(재정의)할 수 있다.
3. 자식 클래스는 부모 클래스의 private 메서드를 상속받을 수 있다.
4. 자식 클래스의 인스턴스는 부모 클래스의 인스턴스 메서드를 호출할 수 있다.

```
정답: 3
(제출한 답: 3)
자바스크립트에서는 private 메서드를 직접 지원하지 않으므로, 자식 클래스가 부모 클래스의 private 메서드를 상속받는 것은 불가능하다.
--- `#` 접두어를 사용하여 private property는 구현할 수 있다.
```

## Q. `Array.prototype.map` 메서드의 구현에서 `call` 메서드의 첫 번째 인자로 전달되는 값은 무엇인가?

1. 콜백 함수
2. thisArg 값 또는 전역 객체
3. 배열의 i번째 요소 값
4. 배열 자체

```
정답: 2
(제출한 답: 2)
call 메서드의 첫 번째 인자는 thisArg 값이 있을 경우 그 값을, 없을 경우 전역 객체를 지정한다. 이를 통해 콜백 함수 내부에서의 this가 될 대상을 명시적으로 바인딩한다.
--- `Array.prototype.<array-method>.call()` 는 `call()` 을 사용하여 Array 메서드를 호출하는 형태이다. 이를 통해 배열이 아닌 객체나 NodeList 도 Array 메서드를 사용할 수 있다.
--- 단, length 속성이 필요하기 때문에 없을 경우 별도로 정의해야 한다. 그렇지 않으면 빈 배열을 반환한다.
--- 매개변수는 thisArg(this 바인딩 객체), ...args(Array 메서드의 매개변수) 순이다.
```

## Q. 다음 중 `Map.keys()` 메서드가 반환하는 것은 무엇인가?

65. 배열
66. 반복 가능한 객체
67. 문자열
68. 숫자

```
정답: 2
(제출한 답: 2)
Map.keys() 메소드는 반복 가능한 객체를 반환한다. 이 객체를 배열로 변환하려면 Array.from() 메소드를 사용해야 한다.
```

## Q. 다음 중 이벤트 믹스인에 대한 설명으로 올바른 것은 무엇인가?

1. 이벤트 믹스인은 이벤트 핸들러를 저장하는 \_eventHandlers 속성을 가지고 있다.
2. 이벤트 믹스인은 .on 메소드를 사용하여 이벤트 핸들러를 제거할 수 있다.
3. 이벤트 믹스인은 .trigger 메소드를 사용하여 이벤트를 생성하지 않는다.
4. 이벤트 믹스인은 클래스의 상속 체인을 방해하지 않고 이벤트 관련 동작을 추가하는 데 사용할 수 없다.

```
정답: 1
(제출한 답: 1)
이벤트 믹스인은 이벤트 핸들러를 저장하는 _eventHandlers 속성을 가지고 있다. .on 메소드를 사용하여 이벤트 핸들러를 추가하고, .off 메소드를 사용하여 이벤트 핸들러를 제거한다. .trigger 메소드를 사용하여 이벤트를 생성하고, 이벤트 믹스인은 클래스의 상속 체인을 방해하지 않고 이벤트 관련 동작을 추가하는 데 사용할 수 있다.
--- https://ko.javascript.info/mixins
```

## Q. 다음 중 `constructor` 속성에 대한 설명으로 올바른 것은 무엇인가?

1. 'constructor' 속성은 기본적으로 모든 함수에 존재한다.
2. 기본 'prototype'을 전체적으로 대체하면 'constructor' 속성이 포함되지 않는다.
3. 'constructor' 속성은 자바스크립트 자체에서 올바른 값을 보장한다.
4. 'constructor' 속성은 객체가 생성된 후에 변경할 수 없다.

```
정답: 1
(제출한 답: 2)
'constructor' 속성은 기본적으로 모든 함수에 존재하지만, 이후에 무슨 일이 일어나는지는 개발자에게 달려있다. 특히, 기본 'prototype'을 전체적으로 대체하면 'constructor' 속성이 포함되지 않는다. 또한, 'constructor' 속성은 자바스크립트 자체에서 올바른 값을 보장하지 않는다.
--- 해설을 보면 2번도 정답이 아닌지?
--- 생성자의 constructor 는 변경되지만, 인스턴스는 아닌 것 같은데 보기에서 대상 객체가 무엇인지?
--- constructor 속성이 정의되어 있지 않더라도 기본적으로 Object 를 참조하기 때문에 2번이 오답인건지?
```

## Q. 다음 중 `try...catch` 구문에 대한 설명으로 옳지 않은 것은 무엇인가?

1. try 블록에서 코드를 실행하고, 오류가 발생하면 catch 블록으로 이동한다.
2. try...catch 구문 없이도 대부분의 환경에서는 '전역' 오류 처리기를 설정하여 '떨어진' 오류를 잡을 수 있다.
3. finally 블록은 try/catch 이후에 어떤 경우에도 실행된다.
4. catch 블록은 특정 오류 유형을 처리하는 것을 기대하므로, 알 수 없는 오류는 다시 던져야 한다.

```
정답: 2
(제출한 답: 2)
try...catch 구문 없이 '전역' 오류 처리기를 설정하는 것은 가능하지만, 이는 오류를 '잡는' 것이 아니라 오류 메시지를 개발자에게 보내는 역할을 한다.
--- '전역' 오류 처리기란 window 객체의 onError 이벤트를 뜻함.
```
